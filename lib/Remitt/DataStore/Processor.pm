#!/usr/bin/perl
#
# $Id$
#
# Authors:
#      Jeff Buchbinder <jeff@freemedsoftware.org>
#
# REMITT Electronic Medical Information Translation and Transmission
# Copyright (C) 1999-2009 FreeMED Software Foundation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# Package: Remitt::DataStore::Processor
#
#	Manage REMITT processor queue using SQL
#

package Remitt::DataStore::Processor;

use FindBin;
use lib "$FindBin::Bin/../lib";

use Remitt::Utilities;
use Remitt::DataStore::Log;
use Data::Dumper;
use Compress::Zlib;
use MIME::Base64;
use DBI;
use POSIX;
use Sys::Syslog;
use File::Path;
use Data::Dumper;

# Method: new
#
# 	Constructor
#
sub new {
	my $class = shift;
	my $self = {};
	bless $self, $class;
	return $self;
} # end constructor

# Method: Create
#
# 	Adds a transaction to the processor queue
#
# Parameters:
#
#	$username - Username
#
# 	$data - Original XML used in the transaction
#
# 	$render - Format used in Render plugin
#
# 	$renderoption - Format used in Render plugin
#
# 	$translation - Translation used
#
# 	$transport - Transport used
#
#	$unique - Unique id for job (generated by Remitt::DataStore::Output)
#
# Return:
#
# 	Integer, row ID for job.
#
sub Create {
	my $self = shift;
	my ( $username, $data, $render, $renderoption, $translation, $transport, $unique ) = @_;

	# Make sure database is initialized
	my $_x = $self->Init();

	# Start deflation
	#my $compressed_data = Compress::Zlib::memGzip($data);
	my $compressed_data = encode_base64(Compress::Zlib::memGzip($data));
	#print "original length = ".length($data)."\n";
	#print "compressed_data/base64 length = ".length($compressed_data)."\n";
	#print Dumper($compressed_data);

	# Open appropriate file
	my $d = $self->_Handle();
	my $s = $d->prepare('INSERT INTO processorqueue '.
		'( username, data, render, renderoption, translation, transport, unique_id ) '.
		'VALUES ( ?, ?, ?, ?, ?, ?, ? )');
	my $r = $s->execute(
		$username,		# name of user
		$compressed_data,	# original data, slightly thinner
		$render,		# render plugin
		$renderoption,		# render option
		$translation,		# translation plugin
		$transport,		# transport plugin
		$unique			# unique id
	);

	# Get id to give back
	my $s2 = $d->prepare('SELECT OID FROM processorqueue ORDER BY OID DESC');
	my $r2 = $s2->execute;
	if ($r2) {
		my $data = $s2->fetchrow_arrayref;
		return $data->[0];
	} else {
		return 0;
	}
} # end method Create

# Method: AddToExecuteQueue
#
# 	Add entry to execute queue
#
# Parameters:
#
# 	$username - Username for job
#
# 	$unique - Unique ID
#
# Returns:
#
# 	OID of entry if successful, else 0
#
sub AddToExecuteQueue {
	my $self = shift;
	my ( $username, $unique ) = @_;

	# Make sure database is initialized
	my $_x = $self->Init();

	my $d = $self->_Handle();
	my $s = $d->prepare('INSERT INTO executequeue ( username, unique_id ) VALUES ( ?, ? )');
	my $r = $s->execute(
		$username,		# name of user
		$unique			# unique id
	);

	# Get id to give back
	my $s2 = $d->prepare('SELECT OID FROM executequeue ORDER BY OID DESC');
	my $r2 = $s2->execute;
	if ($r2) {
		my $data = $s2->fetchrow_arrayref;
		return $data->[0];
	} else {
		return 0;
	}
} # end method AddToExecuteQueue

# Method: GetExecuteQueueCount
#
# 	Get current execute queue count.
#
# Returns:
#
#	Number of items in the execute queue.
#
sub GetExecuteQueueCount {
	my ( $self ) = @_;

	my $log = Remitt::DataStore::Log->new;

	my $_x = $self->Init();
	my $d = $self->_Handle();
	my $s = $d->prepare('SELECT OID FROM executequeue ORDER BY OID');
	my $r = $s->execute;
	if ($r) {
		my $count = 0;
		while (my $data = $s->fetchrow_hashref) {
			$count++;
		}
		#$log->Log('SYSTEM', 3, 'Remitt.DataStore.Processor', 'found '.$count.' items in execute queue');
		return $count;
	} else {
		# No results, return 0
		return 0;
	}
} # end method GetExecuteQueueCount

# Method: GetProcessorQueue
#
# 	Get current processor queue.
#
# Returns:
#
# 	Array of hash of items in processor queue, or undef if none.
#
sub GetProcessorQueue {
	my ( $self ) = @_;

	my $log = Remitt::DataStore::Log->new;

	my $_x = $self->Init();
	my $d = $self->_Handle();
	my $s = $d->prepare('SELECT username, data, render, renderoption, translation, transport, unique_id, OID AS rowid FROM processorqueue ORDER BY OID');
	my $r = $s->execute;
	if ($r) {
		my @results;
		while (my $data = $s->fetchrow_hashref) {
			#$log->Log('SYSTEM', 3, 'Remitt.DataStore.Processor', 'found '.$data->{rowid}.' in processor queue');
			push @results, $data;
		}
		return @results;
	} else {
		return undef;
	}
} # end method GetProcessorQueue

# Method: Init
#
# 	Initialize the database, if this has not been done so already.
#
# Returns:
#
# 	Boolean, depending on success.
#
sub Init {
	my ( $self ) = @_;

	# Open appropriate file
	my $config = Remitt::Utilities::Configuration ( );
	return 1;
} # end method Init

# Method: RemoveFromExecuteQueue
#
# Parameters:
#
#	$username - Username of REMITT user
#
# 	$id - Unique OID describing field
#
sub RemoveFromExecuteQueue {
	my $self = shift;
	my ( $username, $id ) = @_;

	# Get file size
	my $config = Remitt::Utilities::Configuration ( );

	# Make sure database is initialized
	my $_x = $self->Init();
	my $d = $self->_Handle();
	my $s = $d->prepare('DELETE FROM executequeue WHERE username=? AND unique_id=?');
	my $r = $s->execute( $username, $id );
} # end method RemoveFromQueue

# Method: RemoveFromProcessorQueue
#
# Parameters:
#
# 	$id - Unique OID describing field
#
sub RemoveFromProcessorQueue {
	my $self = shift;
	my ( $id ) = @_;

	# Get file size
	my $config = Remitt::Utilities::Configuration ( );

	# Make sure database is initialized
	my $_x = $self->Init();
	my $d = $self->_Handle();
	my $s = $d->prepare('DELETE FROM processorqueue WHERE OID=?');
	my $r = $s->execute( $id );
} # end method RemoveFromProcessorQueue

# Method: _Handle
# 
# 	Return appropriate database handle
# 	
# Returns:
#
# 	DBI handle
#
sub _Handle {
	my ( $self ) = shift;
	return Remitt::Utilities::SqlConnection( );
} # end sub _Handle

sub test {
	$obj = new Remitt::DataStore::Processor->new ( 'test' );
} # end sub test

1;
